---
title: "Analysis and results"
author: "Andrew Heiss, Marc Dotson, and Suparna Chaudhry"
date: "Last run: `r format(Sys.time(), '%F')`"
output: 
  html_document:
    code_folding: hide
    pandoc_args:
      - "--default-image-extension=png"
editor_options: 
  chunk_output_type: console
---

# Load packages

```{r load-packages, warning=FALSE, message=FALSE}
library(tidyverse)
library(fastDummies)
library(rstan)
library(bayesplot)
library(tidybayes)
library(loo)
library(ggridges)
library(ggraph)
library(ggdag)
library(here)

# General settings
source(here("analysis", "options.R"))

# Make all the randomness reproducible
set.seed(1234)

# Set Stan options
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
```


# HMNL model calibration

After selecting the model we'd like to run, model calibration proceeds as follows.

```{r hmnl-model-calibration, eval=FALSE}
intercept <- 1                            # Intercept-only
interactions <- 0                         # Include interactions with the intercept-only model
public_affairs <- 0                       # Public affairs
political_ideology <- 0                   # Political ideology
social_views <- 0                         # Social views
charity_voluntarism <- 0                  # Charity and voluntarism
demographics <- 0                         # Demographics
public_political <- 0                     # Public affairs + Political ideology
public_political_social <- 0              # + Social views
public_political_social_charity <- 0      # + Charity and voluntarism
public_political_social_charity_demo <- 0 # + Demographics

# Load data and design
data <- read_rds(here::here("data", "derived_data", "data.rds"))
X <- read_rds(here::here("data", "derived_data", "hmnl_dummy_design.rds"))
if (interactions == 1) X <- read_rds(here::here("data", "derived_data", "hmnl_dummy_interactions.rds"))

# Restructure choice data Y
Y <- data %>%
  select(contains("Q4")) %>%
  as.matrix()

# Restructure covariate matrix Z
if (intercept == 1) {
  Z <- matrix(data = 1, nrow = dim(X)[1], ncol = 1)
}
if (public_affairs == 1) {
  Z <- data %>%
    select(
      Q2.1, Q2.2, Q2.3_1:Q2.3_7, Q2.4, Q5.7 # Public affairs
    )
}
if (political_ideology == 1) {
  Z <- data %>%
    select(
      Q5.2 # Political ideology
    )
}
if (social_views == 1) {
  Z <- data %>%
    select(
      Q5.6, Q5.11, Q5.8, Q5.9, Q5.10 # Social views
    )
}
if (charity_voluntarism == 1) {
  Z <- data %>%
    select(
      Q2.7, Q2.8, Q2.5, Q2.6, Q2.9, Q2.10, Q5.4, Q5.5, Q5.3_1:Q5.3_10 # Charity and voluntarism
    )
}
if (demographics == 1) {
  Z <- data %>%
    select(
      Q5.12, Q5.13, Q5.14, Q5.15, Q5.16_1:Q5.16_6, Q5.17 # Demographics
    )
}
if (public_political == 1) {
  Z <- data %>%
    select(
      Q2.1, Q2.2, Q2.3_1:Q2.3_7, Q2.4, Q5.7, # Public affairs
      Q5.2                                   # Political ideology
    )
}
if (public_political_social == 1) {
  Z <- data %>%
    select(
      Q2.1, Q2.2, Q2.3_1:Q2.3_7, Q2.4, Q5.7, # Public affairs
      Q5.2,                                  # Political ideology
      Q5.6, Q5.11, Q5.8, Q5.9, Q5.10         # Social views
    )
}
if (public_political_social_charity == 1) {
  Z <- data %>%
    select(
      Q2.1, Q2.2, Q2.3_1:Q2.3_7, Q2.4, Q5.7,                           # Public affairs
      Q5.2,                                                            # Political ideology
      Q5.6, Q5.11, Q5.8, Q5.9, Q5.10,                                  # Social views
      Q2.7, Q2.8, Q2.5, Q2.6, Q2.9, Q2.10, Q5.4, Q5.5, Q5.3_1:Q5.3_10  # Charity and voluntarism
    )
}
if (public_political_social_charity_demo == 1) {
  Z <- data %>%
    select(
      Q2.1, Q2.2, Q2.3_1:Q2.3_7, Q2.4, Q5.7,                           # Public affairs
      Q5.2,                                                            # Political ideology
      Q5.6, Q5.11, Q5.8, Q5.9, Q5.10,                                  # Social views
      Q2.7, Q2.8, Q2.5, Q2.6, Q2.9, Q2.10, Q5.4, Q5.5, Q5.3_1:Q5.3_10, # Charity and voluntarism
      Q5.12, Q5.13, Q5.14, Q5.15, Q5.16_1:Q5.16_6, Q5.17               # Demographics
    )
}

if (intercept == 0) {
  # Replace factor labels with levels
  Z <- Z %>%
    mutate_if(is.factor, as.integer) %>%
    mutate_if(is.integer, as.factor)

  # Pad the variables names with _
  colnames(Z) <- str_c(colnames(Z), "_")

  # Use the output of lm to get a dummy-coded version of the covariate matrix Z
  Z$y <- matrix(rnorm(nrow(Z)), ncol = 1)
  out <- lm(y ~ ., Z, x = TRUE)

  # Save out Z as a matrix, including an intercept
  Z <- tibble(intercept = rep(1, dim(X)[1])) %>%
    bind_cols(as_tibble(out$x[,-1])) %>%
    as.matrix()
}

# Specify the data for calibration in a list
data_list <- list(
  R = dim(X)[1],      # Number of respondents
  S = dim(X)[2],      # Number of choice tasks
  A = dim(X)[3],      # Number of choice alternatives
  I = dim(X)[4],      # Number of (estimable) attribute levels
  J = ncol(Z),        # Number of respondent-level covariates

  Gamma_mean = 0,      # Mean of population-level means
  Gamma_scale = 1,     # Scale of population-level means
  Omega_shape = 5,     # Shape of population-level scale
  tau_mean = 0,        # Mean of population-level scale
  tau_scale = 10,      # Scale of population-level scale

  Y = Y,               # Matrix of observed choices
  X = X,               # Array of experimental designs per choice task
  Z = Z                # Matrix of respondent-level covariates
)

# Run the model and save data and model output
fit <- stan(
  file = here::here("src", "stan_files", "hmnl_noncentered.stan"),
  data = data_list,
  iter = 10000,
  thin = 5,
  seed = 1234
)
run <- list(data = data_list, fit = fit)
if (intercept == 1 & interactions == 0) write_rds(run, here::here("data", "raw_data", "model_runs", "intercept.rds"))
if (intercept == 1 & interactions == 1) write_rds(run, here::here("data", "raw_data", "model_runs", "interactions.rds"))
if (public_affairs == 1) write_rds(run, here::here("data", "raw_data", "model_runs", "public_affairs.rds"))
if (political_ideology == 1) write_rds(run, here::here("data", "raw_data", "model_runs", "political_ideology.rds"))
if (social_views == 1) write_rds(run, here::here("data", "raw_data", "model_runs", "social_views.rds"))
if (charity_voluntarism == 1) write_rds(run, here::here("data", "raw_data", "model_runs", "charity_voluntarism.rds"))
if (demographics == 1) write_rds(run, here::here("data", "raw_data", "model_runs", "demographics.rds"))
if (public_political == 1) write_rds(run, here::here("data", "raw_data", "model_runs", "public_political.rds"))
if (public_political_social == 1) write_rds(run, here::here("data", "raw_data", "model_runs", "public_political_social.rds"))
if (public_political_social_charity == 1) write_rds(run, here::here("data", "raw_data", "model_runs", "public_political_social_charity.rds"))
if (public_political_social_charity_demo == 1) write_rds(run, here::here("data", "raw_data", "model_runs", "public_political_social_charity_demo.rds"))

# Extract and save posterior draws
draws <- fit %>% 
  spread_draws(Gamma[i, j]) %>% 
  ungroup() %>% 
  filter(.iteration > 500) %>% 
  rename(
    i = j,
    j = i
  )

# Save draws
if (intercept == 1 & interactions == 0) write_rds(draws, here::here("data", "raw_data", "posterior_draws", "intercept.rds"))
if (intercept == 1 & interactions == 1) write_rds(draws, here::here("data", "raw_data", "posterior_draws", "interactions.rds"))
if (public_affairs == 1) write_rds(draws, here::here("data", "raw_data", "posterior_draws", "public_affairs.rds"))
if (political_ideology == 1) write_rds(draws, here::here("data", "raw_data", "posterior_draws", "political_ideology.rds"))
if (social_views == 1) write_rds(draws, here::here("data", "raw_data", "posterior_draws", "social_views.rds"))
if (charity_voluntarism == 1) write_rds(draws, here::here("data", "raw_data", "posterior_draws", "charity_voluntarism.rds"))
if (demographics == 1) write_rds(draws, here::here("data", "raw_data", "posterior_draws", "demographics.rds"))
if (public_political == 1) write_rds(draws, here::here("data", "raw_data", "posterior_draws", "public_political.rds"))
if (public_political_social == 1)  write_rds(draws, here::here("data", "raw_data", "posterior_draws", "public_political_social.rds"))
if (public_political_social_charity == 1) write_rds(draws, here::here("data", "raw_data", "posterior_draws", "public_political_social_charity.rds"))
if (public_political_social_charity_demo == 1) write_rds(draws, here::here("data", "raw_data", "posterior_draws", "public_political_social_charity_demo.rds"))
```

The model is calibrated using a non-centered parameterization of a hierarchical multinomial logit model. Each model passed diagnostics checks, including the absence of divergent transitions, as part of model calibration.

```{stan hmnl-noncentered, output.var="hmnl_noncentered", eval=FALSE}
// Index values, hyperprior values, observations, and covariates.
data {
  int<lower = 1> R;                  // Number of respondents.
  int<lower = 1> S;                  // Number of choice tasks.
  int<lower = 2> A;                  // Number of choice alternatives.
  int<lower = 1> I;                  // Number of observation-level covariates.
  int<lower = 1> J;                  // Number of population-level covariates.

  real Gamma_mean;                   // Mean of population-level means.
  real<lower=0> Gamma_scale;         // Scale of population-level means.
  real<lower=0> Omega_shape;         // Shape of population-level scale.
  real tau_mean;                     // Mean of population-level scale.
  real<lower=0> tau_scale;           // Scale of population-level scale.

  int<lower = 1, upper = A> Y[R, S]; // Matrix of observations.
  matrix[A, I] X[R, S];              // Array of observation-level covariates.
  matrix[R, J] Z;                    // Matrix of population-level covariates.
}

// Parameters and hyperparameters.
parameters {
  matrix[J, I] Gamma;                // Matrix of population-level hyperparameters.
  corr_matrix[I] Omega;              // Population model correlation matrix hyperparameters.
  vector<lower = 0>[I] tau;          // Population model vector of scale hyperparameters.
  matrix[R, I] Delta;                // Matrix of non-centered observation-level parameters.
}

// Deterministic transformation.
transformed parameters {
  // Matrix of centered observation-level parameters.
  matrix[R, I] Beta;

  // Non-centered parameterization.
  for (r in 1:R) {
    Beta[r,] = Z[r,] * Gamma + Delta[r,] * quad_form_diag(Omega, tau);
  }
}

// Hierarchical multinomial logit model.
model {
  // Hyperpriors.
  to_vector(Gamma) ~ normal(Gamma_mean, Gamma_scale);
  Omega ~ lkj_corr(Omega_shape);
  tau ~ normal(tau_mean, tau_scale);

  // Non-centered population model and likelihood.
  for (r in 1:R) {
    Delta[r,] ~ normal(0, 1);
    for (s in 1:S) {
      Y[r, s] ~ categorical_logit(X[r, s] * Beta[r,]');
    }
  }
}

// Generated quantities conditioned on parameter draws.
generated quantities {
  // Compute log likelihood for model fit.
  matrix[R, S] log_lik;
  for (r in 1:R) {
    for (s in 1:S) {
      log_lik[r, s] = categorical_logit_lpmf(Y[r, s] | X[r, s] * Beta[r,]');
    }
  }
}
```


# MNL model calibration experimental alternative

```{r mnl-model-calibration, eval=FALSE}
################################################################################
# A flat MNL is an experimental alternative for dealing with interactions.
################################################################################

interactions <- 0 # Include interactions

# Load data and design
data <- read_rds(here::here("data", "derived_data", "data.rds"))
X <- read_rds(here::here("data", "derived_data", "mnl_dummy_design.rds"))
if (interactions == 1) X <- read_rds(here::here("data", "derived_data", "mnl_dummy_interactions.rds"))

# Restructure choice data Y
Y <- data %>%
  select(contains("Q4")) %>%
  pivot_longer(contains("Q4"), names_to = "values") %>%
  select(value) %>%
  as.matrix() %>%
  as.vector()

# Specify the data for calibration in a list
data_list <- list(
  N = dim(X)[1],      # Number of observations
  A = dim(X)[2],      # Number of choice alternatives
  L = dim(X)[3],      # Number of (estimable) attribute levels
  Y = Y,              # Vector of observations
  X = X               # Array of observation-level covariates.
)

# Run the model and save data and model output
fit <- stan(
  file = here::here("src", "stan_files", "mnl.stan"),
  data = data_list,
  iter = 10000,
  thin = 5,
  seed = 1234
)
run <- list(data = data_list, fit = fit)
write_rds(run, here::here("data", "raw_data", "model_runs", "mnl.rds"))
if (interactions == 1) write_rds(run, here::here("data", "raw_data", "model_runs", "mnl_interactions.rds"))

# Extract and save posterior draws
draws <- fit %>% 
  spread_draws(Gamma[i, j]) %>% 
  ungroup() %>% 
  filter(.iteration > 500) %>% 
  rename(
    i = j,
    j = i
  )

# Save draws
write_rds(draws, here::here("data", "raw_data", "posterior_draws", "mnl.rds"))
if (interactions == 1) write_rds(draws, here::here("data", "raw_data", "posterior_draws", "mnl_interactions.rds"))
```

The model is calibrated using a multinomial logit model. Each model passed diagnostics checks, including the absence of divergent transitions, as part of model calibration.

```{stan mnl, output.var="mnl", eval=FALSE}
// Index values, observations, and covariates.
data {
  int<lower = 1> N;                  // Number of observations.
  int<lower = 2> A;                  // Number of choice alternatives.
  int<lower = 1> L;                  // Number of (estimable) attribute levels.

  int<lower = 1, upper = A> Y[N];    // Vector of observations.
  matrix[A, L] X[N];                 // Array of observation-level covariates.
}

// Parameters for the multinomial logit.
parameters {
  vector[L] beta;                    // Vector of aggregate beta coefficients.
}

// Multinomial logit model.
model {
  // Standard normal prior for beta.
  beta ~ normal(0, 5);

  // Multinomial logit.
  for (n in 1:N) {
    Y[n] ~ categorical_logit(X[n] * beta);
  }
}

// Quantities conditioned on parameter draws.
generated quantities {
  // vector[N] Y_new;   // Vector of predicted choices.
  vector[N] log_lik; // Log likelihood to estimate loo.

  // Multinomial logit draws and log likelihood per observation.
  for (n in 1:N) {
    log_lik[n] = categorical_logit_lpmf(Y[n] | X[n] * beta);
  }
}
```


# Original computing environment

<button data-toggle="collapse" data-target="#sessioninfo" class="btn btn-primary btn-md btn-info">Here's what we used the last time we built this page</button>

<div id="sessioninfo" class="collapse">

```{r show-session-info, echo=TRUE, width=100}
writeLines(readLines(file.path(Sys.getenv("HOME"), ".R/Makevars")))

devtools::session_info()
```

</div> 
